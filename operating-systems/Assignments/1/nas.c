/*
  CREATED: Scott Chatham 4/20/13

  nas.c

  This file contains all the code for managing our shell process.
*/

// necessary includes
#include <errno.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <unistd.h>
#include "job.h"
#include "nas.h"

// a declaration for our get_line method defined in a flex file
extern char **get_line();

// our main function
int main( int argc, char *argv[] )
{
  char **args;
  struct Job job;

  while(1) {
    // display prompt
    DisplayPrompt();

    // read input and check for special commands
    args = ReadInput();

    // parse job arguments
    ParseArguments( args, &job );

    // run command
    RunJob( &job );
  }
}

/*
  DisplayPrompt
  RETURNS: void
  ARGUMENTS: void

  This function simply prints our shell prompt to standard input.
*/
void DisplayPrompt()
{
  printf( "> " );
}

/*
  HandleRedirection
  RETURNS: FILE*
  ARGUMENTS: job - a struct Job

  Sets up necessary I/O redirection for the given job.
*/
FILE* HandleRedirection( struct Job *job )
{
  FILE *fp = NULL;

  if( job->redirection != FILE_NULL ) {
    if( job->redirection == FILE_IN ) {
      fp = freopen( job->filename, "r", stdin );
    } else {
      fp = freopen( job->filename, "w", stdout );
    }

    // check for errors
    if( errno ) {
      printf( "%s: %s\n", strerror( errno ), job->filename );
      exit( EXIT_FAILURE );
    }
  }

  return fp;
}

/*
  ParseArguments
  RETURNS: void
  ARGUMENTS: arguments - an array of strings, job - a struct Job

  Fills in the parts of a job specified by arguments.
*/
void ParseArguments( char **arguments, struct Job *job )
{
  int i, count = 0;
  Job_reset( job );

  if( arguments != NULL ) {
    job->command = arguments[0];

    for( i = 0; arguments[i] != NULL; ++i ) {
      if( strcmp( arguments[i], "<" ) == 0 ) {
        job->redirection = FILE_IN;
        if( arguments[++i] != NULL ) job->filename = arguments[i];
      } else if( strcmp( arguments[i], ">" ) == 0 ) {
        job->redirection = FILE_OUT;
        if( arguments[++i] != NULL) job->filename = arguments[i];
      } else if( strcmp( arguments[i], "&" ) == 0 ) {
        job->wait = 0;
      } else { // it's an argument, add it
        job->arguments[count] = arguments[i];
        ++count;
      }
    }
  }
}

/*
  ReadInput
  RETURNS: char**
  ARGUMENTS: void

  This function gets a line from standard input and checks if the command
  is a special one. If so it executes it and returns NULL, otherwise it
  returns the line.
*/
char** ReadInput()
{
  char **args = get_line();
  if( args[0] != NULL && strcmp( args[0], "exit" ) == 0 ) {
    exit( EXIT_SUCCESS );
  } else if( args[0] != NULL && strcmp( args[0], "cd" ) == 0 &&
             args[1] != NULL ) {
    // check if the directory exists
    int status = access( args[1], F_OK );
    if( status != 0 ) {
      printf( "%s: %s\n", strerror( errno ), args[1] );
      return NULL;
    }

    // safe to change directory
    chdir( args[1] );
    return NULL;
  }

  return args;
}

/*
  RunJob
  RETURNS: void
  ARGUMENTS: job - a struct Job

  Takes the given job and attempts to execute it.
*/
void RunJob( struct Job *job )
{
  int pid;
  if( job->command == NULL ) {
    return; // no job to run
  } else {
    pid = fork();
    if( pid == -1 ) { // there was an error
      if( errno ) printf( "%s\n", strerror( errno ) );
      return;
    } else if( pid != 0 ) { // parent process
      if( job->wait ) { // check if we're waiting or not
        waitpid( -1, NULL, 0 );
      } else {
        signal( SIGCHLD, SIG_IGN ); // ignore the signal generated by child process
      }
    } else { // child process
      FILE *fp = HandleRedirection( job );

      execvp( job->command, job->arguments );

      // if we're here, exec failed for some reason, most likely
      // because the command was invalid
      if( errno ) printf( "Invalid command: %s\n", job->command );
      if( fp != NULL ) fclose( fp );
      exit( EXIT_FAILURE );
    }
  }
}
